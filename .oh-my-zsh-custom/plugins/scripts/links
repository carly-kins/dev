#!/usr/bin/env python3

# Based off of code from Federico Menozzi - Thanks Fed! https://github.com/fmenozzi/env/blob/master/scripts/links 

import argparse
import csv
import sqlite3
import pyutils
import shutil
import sys
import questionary

from datetime import datetime, timezone

# Preset entry, title, and notes max column widths for common terminal width
DB_PATH = './.oh-my-zsh-custom/databases/evaluation/evaluation.db'
SCHEMA_PATH = './.oh-my-zsh-custom/databases/evaluation/evaluation_schema.sql'
TYPE_PRESETS = "Is this an Achievement or an Improvement?"
TAGS_PRESETS = "Chose the tags that best fit this achievement or improvement"

WIDTH_PRESETS = {
    114: (21, 21, 11),
    160: (36, 36, 18),
    205: (49, 49, 25),
    230: (51, 51, 25),
}

def create_or_open_db():
    with open(SCHEMA_PATH, 'r') as schema_file:
        schema = schema_file.read()
    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()
    cur.executescript(schema)
    con.commit()
    return con, cur

def entry_exists(id):
    con, cur = create_or_open_db()
    res = cur.execute('SELECT COUNT(*) FROM evalEntries WHERE id = ?', (id,))
    count, = res.fetchone()
    con.close()
    return count == 1

def now_utc():
    return datetime.strftime(datetime.now(timezone.utc), '%Y-%m-%d %H:%M:%S')

#TODO: Add notes column to table
def print_result_table(rows):
    terminal_width = shutil.get_terminal_size().columns
    for terminal_preset_width in sorted(WIDTH_PRESETS.keys()):
        if terminal_width <= terminal_preset_width:
            preset = WIDTH_PRESETS[terminal_preset_width]
            break
    MAX_ENTRY_WIDTH, MAX_TAGS_WIDTH, MAX_TYPE_WIDTH = preset
    def cell(cell_text, max_width):
        if len(cell_text) <= max_width:
            return cell_text
        else:
            return cell_text[:max_width-3] + '...'
    fill_dashes_entry = '─' * (MAX_ENTRY_WIDTH + 2)
    fill_dashes_tags = '─' * (MAX_TAGS_WIDTH + 2)
    fill_dashes_type = '─' * (MAX_TYPE_WIDTH + 2)
    print(f'┌──────┬' + fill_dashes_entry + '┬' + fill_dashes_tags + '┬' + fill_dashes_type + '┐')
    print(f'│  ID  │ {"Entry":^{MAX_ENTRY_WIDTH}} │ {"Tags":^{MAX_TAGS_WIDTH}} │ {"Type":^{MAX_TYPE_WIDTH}} │')
    print(f'├──────┼' + fill_dashes_entry + '┼' + fill_dashes_tags + '┼' + fill_dashes_type + '┤')
    for idx, row in enumerate(rows):
        id, entry, type, _, tags, _= row
        entry, tags, type = (cell(entry, MAX_ENTRY_WIDTH), cell(tags, MAX_TAGS_WIDTH), cell(type, MAX_TYPE_WIDTH))
        print(f'│ {id:^4} │ {entry:{MAX_ENTRY_WIDTH}} │ {tags:{MAX_TAGS_WIDTH}} │ {type:{MAX_TYPE_WIDTH}} │')
        if idx == len(rows) - 1:
            print(f'└──────┴' + fill_dashes_entry + '┴' + fill_dashes_tags + '┴' + fill_dashes_type + '┘')
        else:
            print(f'├──────┼' + fill_dashes_entry + '┼' + fill_dashes_tags + '┼' + fill_dashes_type + '┤')

def stringify_row(row):
    id, entry, type, notes, tags, date_added = row
    return f'{id} {entry} {type} {notes} {tags} {date_added}'

# TODO: Add option to specify date when listing entries options results ----- res = cur.execute('SELECT entry FROM evalEntries ORDER BY date_added ASC;')
def list_entires(args):
    con, cur = create_or_open_db()
    res = cur.execute('SELECT * FROM evalEntries;')
    rows = res.fetchall()
    con.close()
    if not rows:
        return
    if 'csv' in args and args.csv:
        for row in rows:
            (id, entry, type, notes, tags, date_added) = row
            print(f'"{id}","{entry}","{type}","{notes}","{tags}","{date_added}"')
    else:
        print_result_table(rows)

def list_lookup(table):
    con, cur = create_or_open_db()
    res = cur.execute(f'SELECT * FROM {table};')
    rows = res.fetchall()
    con.close()
    
    array = []
    for row in rows:
        ( _, entry ) = row
        array.append(entry)
    return array

# TODO: Add option to make entry last git commit message
def add_entry(args):
    con, cur = create_or_open_db()
    type = questionary.select(TYPE_PRESETS,choices=list_lookup("types_table")).ask()
    notes = args.notes if args.notes else ''
    tags = str(questionary.checkbox(TAGS_PRESETS,choices=list_lookup("tags_table")).ask())
    query = f'''
        INSERT INTO evalEntries (rowid, entry, type, notes, tags, date_added)
        VALUES (NULL, ?, ?, ?, ?, ?);
    '''
    cur.execute(query, (args.entry, type, notes, tags, now_utc()))
    con.commit()
    con.close()

def remove_entry(args):
    if not entry_exists(args.id):
        print(f'Entry id {args.id} not found')
        sys.exit(1)
    con, cur = create_or_open_db()
    cur.execute('DELETE FROM evalEntries WHERE id = ?', (args.id,))
    con.commit()
    con.close()

def update_entry(args):
    if not entry_exists(args.id):
        print(f'Entry id {args.id} not found')
        sys.exit(1)
    con, cur = create_or_open_db()
    if not args.entry and not args.notes and not args.tags:

        print('Must update at least one of entry, notes, tags')
        sys.exit(1)
    
    # TODO: get old entry and print it before changing 
    # TODO: Add option to change type
    if args.entry:
        cur.execute('UPDATE evalEntries SET entry = ? WHERE id = ?', (args.entry, args.id))
    if args.notes:
        cur.execute('UPDATE evalEntries SET notes = ? WHERE id = ?', (args.notes, args.id))
    if args.tags:
        new_tags = str(questionary.checkbox(TAGS_PRESETS,choices=list_lookup("tags_table")).ask())
        if '%t' in new_tags:
            # %t represents the existing tags and is used to make easier modifications.
            old_tags, = cur.execute('SELECT tags FROM evalEntries WHERE id = ?', (args.id,)).fetchone()
            new_tags = new_tags.replace('%t', old_tags)
        cur.execute('UPDATE evalEntries SET tags = ? WHERE id = ?', (new_tags, args.id))
    con.commit()
    con.close()

def find_entry(args):
    con, cur = create_or_open_db()
    if args.query:
        res = cur.execute('SELECT rowid, * FROM evalEntries_fts(?) ORDER BY rank;', (args.query,))
        rows = res.fetchall()
    else:
        res = cur.execute('SELECT * FROM evalEntries;')
        rows = res.fetchall()
        stringified_rows_to_rows = {stringify_row(row): row for row in rows}
        fzf_input = stringified_rows_to_rows.keys()
        fzf_selection = pyutils.fzf(fzf_input)
        if fzf_selection:
            rows = [stringified_rows_to_rows[fzf_selection]]
        else:
            rows = []
    con.close()
    if not rows:
        return
    if args.csv:
        for row in rows:
            id, entry, title, notes, tags, date_added = row
            print(f'"{id}","{entry}","{title}","{notes}","{tags}","{date_added}"')
    else:
        print_result_table(rows)

# TODO: Re-add the ability to upload
# def load_entries(args):
#     with open(args.csv_file, newline='') as csv_file:
#         reader = csv.reader(csv_file, delimiter=',', quotechar='"')
#         data = []
#         for row in reader:
#             if not row:
#                 continue
#             entry, notes, tags = row
#             print(f'Loading {entry}...')
#             title = get_title_from_url(url)
#             data.append({
#                 "entry": entry,
#                 "title": title,
#                 "notes": notes,
#                 "tags": tags,
#                 "date_added": now_utc(),
#             })
#         con, cur = create_or_open_db()
#         cur.executemany(
#             'INSERT INTO evalEntries VALUES(NULL, :entry, :title, :notes, :tags, :date_added);',
#             data
#         )
#         con.commit()
#         con.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    parser.set_defaults(func=list_entires)

    # Passes and works with new functionality 
    parser_list = subparsers.add_parser('ls', help='list all entries')
    parser_list.add_argument('--csv', action='store_true', help='display in csv format')
    parser_list.set_defaults(func=list_entires)

    # TODO: Add Arg to add last git log message
    parser_add = subparsers.add_parser('add', help='add new entry')
    parser_add.add_argument('entry', help='entry for achievement or improvement')
    parser_add.add_argument('-n', '--notes', help='notes for entry')
    parser_add.set_defaults(func=add_entry)

    parser_rm = subparsers.add_parser('rm', help='remove entry')
    parser_rm.add_argument('id', type=int, help='entry id (taken from \'eval ls\')')
    parser_rm.set_defaults(func=remove_entry)

    parser_update = subparsers.add_parser('update', help='update link')
    parser_update.add_argument('id', type=int, help='link id (taken from \'eval ls\')')
    parser_update.add_argument('-e', '--entry', help='update entry')
    parser_update.add_argument('-d', '--notes', help='update notes')
    parser_update.add_argument('-t', action='store_true', help='update tags')
    parser_update.set_defaults(func=update_entry)

    parser_find = subparsers.add_parser('find', help='find links')
    parser_find.add_argument('query', nargs='?', help='search query')
    parser_find.add_argument('--csv', action='store_true', help='display in csv format')
    parser_find.set_defaults(func=find_entry)

    # parser_load = subparsers.add_parser('load', help='load links from csv (entry,entr,tags)')
    # parser_load.add_argument('csv_file', help='csv file (entry,entr,tags)')
    # parser_load.set_defaults(func=load_entries)

    parser_tags = subparsers.add_parser('types', help='list all types')
    parser_tags.set_defaults(func=list_lookup("types_table"))

    parser_tags = subparsers.add_parser('tags', help='list all tags')
    parser_tags.set_defaults(func=list_lookup("tags_table"))

    args = parser.parse_args()
    args.func(args)