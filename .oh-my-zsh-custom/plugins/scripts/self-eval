#!/usr/bin/env python3

# Based off of code from Federico Menozzi - Thanks Fed! https://github.com/fmenozzi/env/blob/master/scripts/links 
import os
import argparse
import csv
import sqlite3
import pyutils
import shutil
import sys
import questionary
import subprocess

from datetime import datetime, timezone

# Preset entry, title, and notes max column widths for common terminal width
HOME= os.getenv('HOME')
DB_PATH = f'{HOME}/dev/.oh-my-zsh-custom/databases/evaluation/evaluation.db'
SCHEMA_PATH = f'{HOME}/dev/.oh-my-zsh-custom/databases/evaluation/evaluation_schema.sql'
TYPES_PRESETS = 'Achievement / Improvement:'
TAGS_PRESETS = 'Self-Eval Tags:'
ENTRY_PRESETS= 'Entry:'
NOTES_PRESETS= 'Notes:'

WIDTH_PRESETS = {
    114: (21, 21, 11),
    160: (36, 36, 18),
    205: (49, 49, 25),
    230: (51, 51, 25),
}

def create_or_open_db():
    with open(SCHEMA_PATH, 'r') as schema_file:
        schema = schema_file.read()
    con = sqlite3.connect(DB_PATH)
    cur = con.cursor()
    cur.executescript(schema)
    con.commit()
    return con, cur

def entry_exists(id):
    con, cur = create_or_open_db()
    res = cur.execute('SELECT COUNT(*) FROM evalEntries WHERE id = ?', (id,))
    count, = res.fetchone()
    con.close()
    return count == 1

def now_utc():
    return datetime.strftime(datetime.now(timezone.utc), '%Y-%m-%d %H:%M:%S')

#TODO: Add notes column to table
def print_result_table(rows):
    terminal_width = shutil.get_terminal_size().columns
    for terminal_preset_width in sorted(WIDTH_PRESETS.keys()):
        if terminal_width <= terminal_preset_width:
            preset = WIDTH_PRESETS[terminal_preset_width]
            break
    MAX_ENTRY_WIDTH, MAX_TAGS_WIDTH, MAX_TYPES_WIDTH = preset
    def cell(cell_text, max_width):
        if len(cell_text) <= max_width:
            return cell_text
        else:
            return cell_text[:max_width-3] + '...'
    fill_dashes_entry = '─' * (MAX_ENTRY_WIDTH + 2)
    fill_dashes_tags = '─' * (MAX_TAGS_WIDTH + 2)
    fill_dashes_types = '─' * (MAX_TYPES_WIDTH + 2)
    print(f'┌──────┬' + fill_dashes_entry + '┬' + fill_dashes_tags + '┬' + fill_dashes_types + '┐')
    print(f'│  ID  │ {"Entry":^{MAX_ENTRY_WIDTH}} │ {"Tags":^{MAX_TAGS_WIDTH}} │ {"Type":^{MAX_TYPES_WIDTH}} │')
    print(f'├──────┼' + fill_dashes_entry + '┼' + fill_dashes_tags + '┼' + fill_dashes_types + '┤')
    for idx, row in enumerate(rows):
        id, entry, types, _, tags, _= row
        entry, tags, types = (cell(entry, MAX_ENTRY_WIDTH), cell(tags, MAX_TAGS_WIDTH), cell(types, MAX_TYPES_WIDTH))
        print(f'│ {id:^4} │ {entry:{MAX_ENTRY_WIDTH}} │ {tags:{MAX_TAGS_WIDTH}} │ {types:{MAX_TYPES_WIDTH}} │')
        if idx == len(rows) - 1:
            print(f'└──────┴' + fill_dashes_entry + '┴' + fill_dashes_tags + '┴' + fill_dashes_types + '┘')
        else:
            print(f'├──────┼' + fill_dashes_entry + '┼' + fill_dashes_tags + '┼' + fill_dashes_types + '┤')

def stringify_row(row):
    id, entry, types, notes, tags, date_added = row
    return f'{id} {entry} {types} {notes} {tags} {date_added}'

# TODO: Add option to specify date when listing entries options results ----- res = cur.execute('SELECT entry FROM evalEntries ORDER BY date_added ASC;')
def list_entires(args):
    con, cur = create_or_open_db()
    res = cur.execute('SELECT * FROM evalEntries;')
    rows = res.fetchall()
    con.close()
    if not rows:
        return
    if 'csv' in args and args.csv:
        for row in rows:
            (id, entry, types, notes, tags, date_added) = row
            print(f'"{id}","{entry}","{types}","{notes}","{tags}","{date_added}"')
    else:
        print_result_table(rows)

def list_lookup(table):
    con, cur = create_or_open_db()
    res = cur.execute(f'SELECT * FROM {table};')
    rows = res.fetchall()
    con.close()
    
    array = []
    for row in rows:
        ( _, entry ) = row
        array.append(entry)
    return array

def add_entry(args):
    con, cur = create_or_open_db()
    types = questionary.select(TYPES_PRESETS,choices=list_lookup('types_table')).ask()
    tags = str(questionary.checkbox(TAGS_PRESETS,choices=list_lookup('tags_table')).ask())
    query = f'''
        INSERT INTO evalEntries (rowid, entry, types, notes, tags, date_added)
        VALUES (NULL, ?, ?, ?, ?, ?);
    '''
    if args.git: 
        notes = questionary.text(NOTES_PRESETS).ask() if args.notes else ''
        try:
            git = subprocess.run(['git', 'log', '-1', '--pretty=%B'], capture_output=True, text=True, check=True)
            git_string = git.stdout.strip()
        except subprocess.CalledProcessError as e:
            # Handle errors, if any
            print(f"Error: {e}")
            return None
        cur.execute(query, (git_string, types, notes, tags, now_utc()))
    else: 
        entry = questionary.text(ENTRY_PRESETS).ask()
        notes = questionary.text(NOTES_PRESETS).ask() if args.notes else ''
        cur.execute(query, (entry, types, notes, tags, now_utc()))
    con.commit()
    con.close()

def remove_entry(args):
    if not entry_exists(args.id):
        print(f'Entry id {args.id} not found')
        sys.exit(1)
    con, cur = create_or_open_db()
    cur.execute('DELETE FROM evalEntries WHERE id = ?', (args.id,))
    con.commit()
    con.close()

def update(data, col, table, args, question, tags):
    if not tags: 
        e = question
        data.execute(f'UPDATE {table} SET {col} = ? WHERE id = ?', (e, args))
    else:
        new_t = question
        if '%t' in new_t:
            # %t represents the existing tags and is used to make easier modifications.
            old_t, = data.execute(f'SELECT {col} FROM {table} WHERE id = ?', (args,)).fetchone()
            new_t = new_t.replace('%t', old_t)
        data.execute(f'UPDATE {table} SET {col} = ? WHERE id = ?', (new_t, args))
    

def update_entry(args):
    if not entry_exists(args.id):
        print(f'Entry id {args.id} not found')
        sys.exit(1)
    con, cur = create_or_open_db()
    if not args.entry and not args.notes and not args.tags:
        print('Must update at least one of entry, notes, tags')
        sys.exit(1)
    if args.entry:
        update(cur, 'entry', 'evalEntries', args.id, questionary.text(ENTRY_PRESETS).ask(), False)
    if args.notes:
        update(cur, 'notes', 'evalEntries', args.id, questionary.text(NOTES_PRESETS).ask(), False)
    if args.tags:
        update(cur, 'tags', 'evalEntries', args.id, str(questionary.checkbox(TAGS_PRESETS,choices=list_lookup('tags_table')).ask()), True)
    if args.types:
        update(cur, 'tags', 'evalEntries', args.id, questionary.select(TYPES_PRESETS,choices=list_lookup('types_table')).ask(), True)
    con.commit()
    con.close()

def find_entry(args):
    con, cur = create_or_open_db()
    if args.query:
        res = cur.execute('SELECT rowid, * FROM evalEntries_fts(?) ORDER BY rank;', (args.query,))
        rows = res.fetchall()
    else:
        res = cur.execute('SELECT * FROM evalEntries;')
        rows = res.fetchall()
        stringified_rows_to_rows = {stringify_row(row): row for row in rows}
        fzf_input = stringified_rows_to_rows.keys()
        fzf_selection = pyutils.fzf(fzf_input)
        if fzf_selection:
            rows = [stringified_rows_to_rows[fzf_selection]]
        else:
            rows = []
    con.close()
    if not rows:
        return
    if args.csv:
        for row in rows:
            id, entry, title, notes, tags, date_added = row
            print(f'"{id}","{entry}","{title}","{notes}","{tags}","{date_added}"')
    else:
        print_result_table(rows)

# TODO: Re-add the ability to upload
# def load_entries(args):
#     with open(args.csv_file, newline='') as csv_file:
#         reader = csv.reader(csv_file, delimiter=',', quotechar='"')
#         data = []
#         for row in reader:
#             if not row:
#                 continue
#             entry, notes, tags = row
#             print(f'Loading {entry}...')
#             title = get_title_from_url(url)
#             data.append({
#                 "entry": entry,
#                 "title": title,
#                 "notes": notes,
#                 "tags": tags,
#                 "date_added": now_utc(),
#             })
#         con, cur = create_or_open_db()
#         cur.executemany(
#             'INSERT INTO evalEntries VALUES(NULL, :entry, :title, :notes, :tags, :date_added);',
#             data
#         )
#         con.commit()
#         con.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    parser.set_defaults(func=list_entires)

    parser_list = subparsers.add_parser('ls', help='list all entries')
    
    parser_list.add_argument('--csv', action='store_true', help='display in csv format')
    parser_list.set_defaults(func=list_entires)

    # TODO: Add Arg to add last git log message
    parser_add = subparsers.add_parser('add', help='add new entry')
    parser_add.add_argument('--git', action='store_true', help='add last git commit message as entry')
    parser_add.add_argument('-n', '--notes', action='store_true', help='add notes to entry')
    parser_add.set_defaults(func=add_entry)

    parser_rm = subparsers.add_parser('rm', help='remove entry')
    parser_rm.add_argument('id', type=int, help='entry id (taken from \'self-eval ls\')')
    parser_rm.set_defaults(func=remove_entry)

    parser_update = subparsers.add_parser('update', help='update entry')
    parser_update.add_argument('id', type=int, help='entry id (taken from \'self-eval ls\')')
    parser_update.add_argument('-e', '--entry', action='store_true', help='update entry')
    parser_update.add_argument('-n', '--notes', action='store_true', help='update notes')
    parser_update.add_argument('-t', '--tags', action='store_true', help='update tags')
    parser_update.add_argument('-ty', '--types', action='store_true', help='update types')
    parser_update.set_defaults(func=update_entry)

    parser_find = subparsers.add_parser('find', help='find links')
    parser_find.add_argument('query', nargs='?', help='search query')
    parser_find.add_argument('--csv', action='store_true', help='display in csv format')
    parser_find.set_defaults(func=find_entry)

    # parser_load = subparsers.add_parser('load', help='load links from csv (entry,entr,tags)')
    # parser_load.add_argument('csv_file', help='csv file (entry,entr,tags)')
    # parser_load.set_defaults(func=load_entries)

    parser_tags = subparsers.add_parser('types', help='list all types')
    parser_tags.set_defaults(func=list_lookup('types_table'))

    parser_tags = subparsers.add_parser('tags', help='list all tags')
    parser_tags.set_defaults(func=list_lookup('tags_table'))

    args = parser.parse_args()
    args.func(args)